#Homework 1

When talking about the challenges of software engineering, Brooks says that the difficulties can be divided into two categories.
*Essential difficulties* are problems that effect a fundamental aspect of the software. Another way to think of it is as a real
difficulty because it involves the real essense of the software. One example of an essential difficulty is a bug in a software
system with registered users that has a bug that doesn't allow users to click submit when creating an account. This is an essential
difficulty because it affects something that is necessary for the product to be used. 

The other type of software difficulty is an *accidental difficulty*. This kind of problem arises from the production of the software
but are not part of its nature. According to Brooks, most of the solutions to problems solve accidental difficulties, but most of the
important problems that really need to be solved come from essential difficulties. An example of an accidental difficulty is a browser
based test that fails on certain browsers that are slower than the one the tests were written in.

*Complexity* refers to the intrinsic hardship of software. This complexity faced in software engineering is complex because it exists in the
real world and the real world is complex. An application that monitors heart rate and notifies patients with conditions of potentially dangerous
situations is complex. *Conformity* is complexity that comes from some unspecified choices or actions that happen along the production process. An 
example of conformity is an senior engineer that tells a junior engineer to use Java to write a small script. This makes the work more complex than it
could be for the junior enginner who could be using an easier langugae to complete this simple task. *Changeability* is the pressure to change software 
because it is often the cheapest and easiet thing to change. An example of this can be seen in video games, especially online ones that can be updated
easily. Gamers who play get bored after they've explored everything the game has to offer and want new features. *Invisibility* refers to the invisible nature
of software. It cannot be converted to some sort of display that can be viewed and understood. An example of invisibility is the control flow of a program. A
control flow graph can be made, and may be useful for a relatively small program, but it is just as complicated to view for a very large one.

A *silver bullet* is a 
>single technology or technique that by itself can deilver one order-of-magnitude improvement to some aspect of software engineering.

Brooks says that an order-of-magnitude improvement on software engineering would not happen because of two reasons. First, most of the solutions in software engineering
solve accidental difficulties, but most of the real problems come form essential difficulties. Second, tools would not be allowed to create any accidental difficulties, but
they almost always do.

A chemist studies chemistry. He or she understands everything about chemistry, then experiments and researches to push the boundaries of the current existing understanding of
chemistry. A chemical engineer understands and uses concepts from the studies created by chemists about chemistry to build something concrete that will be used out in the world.
Similar to this analogy, a software engineer builds software using concepts known from the studies of computer scientists.

*Abstraction* is the breakdown and organization of a computer program's complexity. This is important because many software engineering problems are too complex to solved as
themselves, so they must be split up and arranged to be solved. There are many different layers when it comes to the language of software engineering: users, developers, code, machine
code, compilers, etc. In order to have a functioning system all these pieces must connect somehow and they do so through *conversations*. Software engineers need to *specify* everything that they
do because the system is so complex, and there are often many different ways to do one thing. Software engineering involves a lot of *translation*. Since there are multiple frameworks, languages, 
specifications, etc that can be used, it is natural that a software project will go through many translations throughout its lifetime. Software engineers use *iteration* to complete projects, 
which is to start small and complete the project step-by-step. Iteration is important because large, complicated programs should not be written all at once. It's likely there will be so many 
errors the first time its compile the developer won't even know what to do. It is much easier to compile in steps to stay organized and on track.
